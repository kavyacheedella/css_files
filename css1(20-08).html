<!DOCTYPE html>
<html lang="en">

<!-- 
🔹 1. Block Elements

Sentence: “A block element always starts on a new line and takes up the full width available.”

Height and width can be set.

Examples: <div>, <p>, <h1>–<h6>, <section>.

<address>, <article>, <aside>, <blockquote>, <canvas>, <dd>, <div>,
<dl>, <dt>, <fieldset>, <figcaption>, <figure>, <footer>, <form>, 
<h1>–<h6>, <header>, <hr>, <li>, <main>, <nav>, <noscript>, <ol>, 
<p>, <pre>, <section>, <table>, <tfoot>, <ul>, <video>

<div style="border:1px solid red;">This is a DIV</div>
<p style="border:1px solid blue;">This is a Paragraph</p>
<h1 style="border:1px solid green;">This is a Heading</h1>

🔹 2. Inline Elements

Sentence: “An inline element does not start on a new line and only takes up as much width as its content.”

Height and width cannot be set directly.

Examples: <span>, <a>, <strong>, <em>.

    The <span> tag in HTML is an inline container used to group text or other inline elements for styling or scripting purposes.
        <span> = "Apply style/JS to a specific word or phrase inside a line, without breaking the layout."

<p>This is <span style="border:1px solid green;">Inline</span> text.</p>

<a>, <abbr>, <acronym>, <b>, <bdo>, <big>, <br>, <button>, <cite>, 
<code>, <dfn>, <em>, <i>, <img>, <input>, <kbd>, <label>, <map>, 
<object>, <output>, <q>, <samp>, <script>, <select>, <small>, <span>, 
<strong>, <sub>, <sup>, <textarea>, <time>, <tt>, <var>

🔹 3. Inline-Block Elements

Sentence: “An inline-block element behaves like inline (does not break line) but allows setting width and height like a block element.”

Best of both worlds.

Examples (when styled): <img>, <button>, or custom <div style="display:inline-block;">.

    <img>, <button>, <input>, <textarea>, <select>, <label>

✅ Summary

Block → structure/containers (div, section, p, h1–h6).

Inline → text-level formatting (span, a, b, em, img).

Inline-block → form controls/images (img, input, button), or any tag with display:inline-block;.

🔹 1. Formatting Tags in HTML

Formatting tags are used to change the appearance of text.

Here’s a list of the most common ones:

Tag	Use	Example
<b>	Bold text (without meaning)	<b>Bold</b> → Bold
<strong>	Important text (semantic)	<strong>Important</strong> → Important
<i>	Italic text (without meaning)	<i>Italic</i> → Italic
<em>	Emphasized text (semantic)	<em>Emphasized</em> → Emphasized
<mark>	Highlighted text	<mark>Highlighted</mark> → <mark>Highlighted</mark>
<small>	Smaller text	<small>Small text</small> → <small>Small text</small>
<del>	Deleted/strikethrough text	<del>Deleted</del> → Deleted
<ins>	Inserted/underlined text	<ins>Inserted</ins> → <ins>Inserted</ins>
<sub>	Subscript	H<sub>2</sub>O → H₂O
<sup>	Superscript	X<sup>2</sup> → X²

🔹 2. HTML Entities

Entities are used to display reserved characters (like <, >, &) or special symbols (like ©, ®, →).

Entity	Symbol	Example
&lt;	<	&lt;div&gt; → <div>
&gt;	>	&gt; → >
&amp;	&	&amp; → &
&quot;	"	&quot;Hello&quot; → "Hello"
&apos;	'	&apos; → '
&nbsp;	(non-breaking space)	Hello&nbsp;World → Hello World
&copy;	©	&copy; 2025 → © 2025
&reg;	®	OpenAI&reg; → OpenAI®
&trade;	™	ChatGPT&trade; → ChatGPT™
&euro;	€	&euro; → €
&yen;	¥	&yen; → ¥
&pound;	£	&pound; → £
&hearts;	♥	&hearts; → ♥
 -->


    <!-- 1.inline styles - styles are applied directly to the html elements using the style attributes.
    2.internal styles - styles are defined within the head section of the html document using the style tag.
    3.external styles - styles are defined in a separate css file and linked to the html document using the link tag.

      css rule set----

      slector {
        property:value;}
    
    selector types - simple,combinators,pseudoclasses,pseudoelements,attribute selectors

    simple selectors - element selector ,class selector (.) , id selector (#) , grouping selector (,) , universal selector(*)
    id has higher specificity than class selector
    class has higher specificity than element selector -->
    
     <!--  box model - content , padding , border , margin
    The box model explains how the browser calculates the space an element takes on the page → Content + Padding + Border + Margin.
    content - width and height of the element
    padding - space b/w content and border
    padding properties- padding-top,padding-bottom,padding-right,padding-left
    border - space b/w padding and margin
    border properties - border-style,border-width,border-color,border-radius,border-left,right,top,bottom
    margin - space b/w border and other elments
    margin propertie - margin-top,margin-bottom,margin-right,margin-left -->

    <!-- css units - px,em,rem,%,vw,vh,cm,mm,in,ch,ex

    in css negative values -pull the content towards the left or top
    positive values - push the content towards the right or bottom 
    border shorthand - px,style,color -->
    
    <!-- 
    position controls where an element sits in relation to the page, its parent, or the viewport.
    position property--- 5 values
    1)static -- default value
    2)absolute --  top="value" , bottom="value" , right="value" , left="value"
    3)relative -- top="value" , bottom="value" , right="value" , left="value"
    4)sticky -- top="value" , bottom="value" , right="value" , left="value"
    5)fixed -- top="value" , bottom="value" , right="value" , left="value"

    syntax:
    selector{
    property:value
    }

    selector{
    position:static,absolute,relative,sticky,fixed
    }
    classname{
    display:inline:block;
    display:block;
    display:inline-block;
    display:none; it does not show the container another conatiner will replace in that place if we use display none for one container.
    visibility:hidden; it hides the container and place of that container have their place and cannot replace the other container in that place.

    z-index = “layer number” for overlapping elements. Higher values are on top, lower values are behind.
    z-index controls the stacking order of elements on a webpage.
    It decides which element appears on top of or behind another when they overlap

    text-tranform:captalize,lowercase,uppercase;
    }
     -->

     <!-- 
          Combinators--
          4 types of selectors
          1.child sibling selector (>)
          2.descendent selector  (space)
          3.adjacent sibiling selector (+) or next sibling sele
          4.general sibling selctor (~)
these are most impacted in pseudo classes and pseudo elements.
     
<!DOCTYPE html>
<html>
<head>
  <title>Selectors Example</title>
</head>
<body>
  <div class="container">
    <h1 id="main-title">Welcome</h1>
    <p>This is a paragraph inside container.</p>
    <div class="box">
      <p class="highlight">This is inside the box.</p>
      <span>Some span text</span>
    </div>
    <p>This is another paragraph after box.</p>
  </div>
  <p>Paragraph outside container</p>
</body>
</html>

 🔹 Basic Selectors
1. Universal Selector (*)

Sentence: “Selects all elements on the page.”

* { color: blue; }

2. Type Selector (element selector)

Sentence: “Selects all elements of a given HTML tag.”

p { color: red; }   /* all <p> elements */

3. Class Selector (.classname)

Sentence: “Selects all elements with the specified class attribute.”

.box { background: yellow; }

4. ID Selector (#idname)

Sentence: “Selects the element with the specified ID (unique on a page).”

#header { font-size: 20px; }

5. Group Selector (,)

Sentence: “Selects multiple different elements and applies the same style.”

h1, h2, p { font-family: Arial; }

🔹 Attribute Selectors
6. Attribute Selector ([attr])

Sentence: “Selects elements that have the specified attribute.”

input[type] { border: 1px solid black; }


7. Attribute Value Selector ([attr="value"])

Sentence: “Selects elements where the attribute has the specified value.”

input[type="text"] { background: lightgray; }

🔹 Pseudo-classes
8. Pseudo-class Selector (:hover, :focus, etc.)

Sentence: “Selects elements in a specific state or condition.”

a:hover { color: green; }   /* when mouse is over link */

🔹 Pseudo-elements
9. Pseudo-element Selector (::before, ::after, ::first-letter)

Sentence: “Selects and styles specific parts of an element.”

p::first-letter { font-size: 24px; color: red; }



🔹 1. Descendant Combinator (space )

👉 Selects all elements that are inside (nested anywhere) within another element.

div p { ... }


Sentence: “Select all <p> elements that are descendants of a <div>.”

🔹 2. Child Combinator (>)

👉 Selects elements that are direct children only of another element.

div > p { ... }


Sentence: “Select all <p> elements that are direct children of a <div>.”

🔹 3. Adjacent Sibling Combinator (+)

👉 Selects the immediately next sibling of an element.

h1 + p { ... }


Sentence: “Select the first <p> element that comes immediately after an <h1>.”

🔹 4. General Sibling Combinator (~)

👉 Selects all siblings that come after an element (not just the first).

h1 ~ p { ... }


Sentence: “Select all <p> elements that are siblings of an <h1> and come after it.”

    ✅ In short, sentences:

Descendant ( ) → “All nested inside.”

Child (>) → “Direct children only.”

Adjacent (+) → “The very next sibling.”

General (~) → “All later siblings.”
        
      -->

<!--  

🔹 Common Display Values

1. block

Takes up the full width of the page.

Always starts on a new line.

Width/height can be set.

div {
  display: block;
}


👉 Example: <div>, <p>, <h1>

2. inline

Takes only as much space as its content.

Does not start on a new line.

Width/height cannot be set.

span {
  display: inline;
}


👉 Example: <span>, <a>, <strong>

3. inline-block

Behaves like inline (stays in same line).

But allows setting width and height like block.

button {
  display: inline-block;
}


👉 Example: <button>, <img>

4. none

Hides the element completely (it won’t take space).

h1 {
  display: none;
}

5. flex

Makes the container a flexbox.

Lets you arrange child elements in a row/column, align, justify, etc.

.container {
  display: flex;
}

6. grid

Makes the container a grid.

Allows arranging items in rows and columns.

.container {
  display: grid;
}

7. list-item

Makes the element behave like <li> (list item with marker).

p {
  display: list-item;
}

8. table, table-row, table-cell

Makes elements behave like table parts.

div {
  display: table;
}
span {
  display: table-cell;
}
      
🔹 What is display: flex;?

It turns a container into a flexbox.

Flexbox makes it easy to arrange items in rows or columns, and to control alignment, spacing, and order.

Think of it like a magic box 📦 that arranges its children neatly without you doing lots of math.

👉 Example:

<div style="display:flex; border:2px solid black;">
  <div style="background:red; width:50px; height:50px;"></div>
  <div style="background:blue; width:50px; height:50px;"></div>
  <div style="background:green; width:50px; height:50px;"></div>
</div>


✅ The 3 boxes automatically line up in a row.

🔹 Important Flex Properties
1. Flex Direction

Controls the direction of items inside flexbox.

.container {
  display: flex;
  flex-direction: row;      /* Default: left to right */
  flex-direction: row-reverse; /* Right to left */
  flex-direction: column;      /* Top to bottom */
  flex-direction: column-reverse; /* Bottom to top */
}

2. Justify Content

Aligns items horizontally (main axis).

.container {
  justify-content: flex-start;  /* Default: items at left */
  justify-content: flex-end;    /* Items at right */
  justify-content: center;      /* Items in center */
  justify-content: space-between; /* Equal gaps between items */
  justify-content: space-around;  /* Equal space around items */
  justify-content: space-evenly;  /* Equal spacing everywhere */
}

3. Align Items

Aligns items vertically (cross axis).

.container {
  align-items: stretch;    /* Default: stretch to container height */
  align-items: flex-start; /* Top */
  align-items: flex-end;   /* Bottom */
  align-items: center;     /* Middle */
  align-items: baseline;   /* Based on text baseline */
}

4. Align Content

Used when there are multiple rows (like wrapping items).

.container {
  flex-wrap: wrap; /* needed for align-content */
  align-content: flex-start;
  align-content: flex-end;
  align-content: center;
  align-content: space-between;
  align-content: space-around;
  align-content: stretch; /* default */
}

5. Flex Wrap

Controls whether items stay in one line or wrap.

.container {
  flex-wrap: nowrap; /* default */
  flex-wrap: wrap;   /* items wrap to next line */
  flex-wrap: wrap-reverse; /* wrap but reversed */
}

6. Gap (modern shortcut for spacing)
.container {
  display: flex;
  gap: 20px; /* adds spacing between flex items */
}

7. Order (per item)

Changes the order of items without changing HTML.

.item1 { order: 2; }
.item2 { order: 1; }
.item3 { order: 3; }

8. Flex Grow, Shrink, and Basis

These are applied to individual items:

.item {
  flex-grow: 1;   /* how much item can grow */
  flex-shrink: 1; /* how much item can shrink */
  flex-basis: 100px; /* starting size */
}


Shortcut:

.item { flex: 1 1 100px; } /* grow, shrink, basis */


✅ Summary in one line:

display: flex; makes layouts easier.

Main properties:

flex-direction → row or column

justify-content → horizontal alignment

align-items → vertical alignment

flex-wrap → wrapping items

gap → spacing

order and flex → control individual items


🔹 What does flex-wrap mean?

When you use display: flex, all items are put in one line by default (no matter how many).
👉 If they don’t fit, they shrink and squeeze into the same line.

The flex-wrap property tells the browser what to do when items don’t fit in one line.

✅ Values of flex-wrap

nowrap (default)
👉 All items stay in one line, even if they overflow.

.container {
  display: flex;
  flex-wrap: nowrap; /* default */
}


wrap
👉 Items will move to the next line if there’s not enough space.

.container {
  display: flex;
  flex-wrap: wrap;
}


wrap-reverse
👉 Same as wrap, but items move to the next line in the reverse direction.

.container {
  display: flex;
  flex-wrap: wrap-reverse;
}

🔹 Example:
<div style="display:flex; flex-wrap:wrap; border:2px solid black; width:250px;">
  <div style="background:red; width:100px; height:50px;">1</div>
  <div style="background:blue; width:100px; height:50px;">2</div>
  <div style="background:green; width:100px; height:50px;">3</div>
  <div style="background:orange; width:100px; height:50px;">4</div>
</div>


👉 Here, since the container width is 250px, only 2 boxes fit per row.
The rest wrap to the next line.

✅ In short:

nowrap = all in one row (default).

wrap = move to new line when needed.

wrap-reverse = move to new line but in reverse order.

🔹 When you write:
.container {
  display: flex;
}


👉 This only makes the container a flexbox.
It does not directly set flex-shrink or flex-grow.

🔹 What happens to the children (flex items)?

When elements become flex items (because the parent has display: flex), the browser gives them these default values:

flex-grow: 0;
flex-shrink: 1;   /* ✅ yes, shrink = 1 by default */
flex-basis: auto;


That is the same as writing:

flex: 0 1 auto;


✅ So the answer:

display: flex itself doesn’t set flex-shrink.

But it makes the children into flex items, and flex items by default get flex-shrink: 1.

👉 Example:

<div class="container">
  <div class="box">A</div>
  <div class="box">B</div>
  <div class="box">C</div>
</div>

<style>
.container {
  display: flex;
  width: 200px; /* small container */
  border: 2px solid black;
}
.box {
  width: 100px; /* each wants 100px */
  background: lightblue;
  margin: 5px;
}
</style>


Each box wants 100px, total = 300px.

Container is only 200px wide.

Because flex-shrink = 1 (default) → boxes shrink to fit.

👉 If you add:

.box {
  flex-shrink: 0;
}


Then they won’t shrink, and they’ll overflow outside the container.


🔹 Flexbox Properties

We divide them into two groups:

1️⃣ Flex Container Properties (applied to the parent box)

These control how child items are arranged.


| Property            | Values                                                                              | Use                                             |
| ------------------- | ----------------------------------------------------------------------------------- | ----------------------------------------------- |
| **flex-direction**  | `row` (default), `row-reverse`, `column`, `column-reverse`                          | Sets the direction of items                     |
| **flex-wrap**       | `nowrap` (default), `wrap`, `wrap-reverse`                                          | Controls wrapping of items                      |
| **flex-flow**       | shorthand → `flex-direction flex-wrap`                                              | Example: `flex-flow: row wrap;`                 |
| **justify-content** | `flex-start`, `flex-end`, `center`, `space-between`, `space-around`, `space-evenly` | Aligns items **horizontally** (main axis)       |
| **align-items**     | `stretch` (default), `flex-start`, `flex-end`, `center`, `baseline`                 | Aligns items **vertically** (cross axis)        |
| **align-content**   | `stretch`, `flex-start`, `flex-end`, `center`, `space-between`, `space-around`      | Aligns **multiple rows** (when wrap is used)    |
| **gap**             | `<length>`                                                                          | Adds spacing between items (e.g., `gap: 10px;`) |


2️⃣ Flex Item Properties (applied to the children inside the flex container)

These control individual item behavior.

| Property        | Values                                                            | Use                                            |
| --------------- | ----------------------------------------------------------------- | ---------------------------------------------- |
| **order**       | `<number>`                                                        | Controls the order of items (default `0`)      |
| **flex-grow**   | `<number>`                                                        | How much an item can grow relative to others   |
| **flex-shrink** | `<number>`                                                        | How much an item can shrink relative to others |
| **flex-basis**  | `<length>` (e.g., `100px`, `auto`)                                | The initial size of an item                    |
| **flex**        | shorthand → `flex-grow flex-shrink flex-basis`                    | Example: `flex: 1 0 200px;`                    |
| **align-self**  | `auto`, `flex-start`, `flex-end`, `center`, `baseline`, `stretch` | Overrides `align-items` for one item           |


✅ Summary in one line:

Container properties: flex-direction, flex-wrap, flex-flow, justify-content, align-items, align-content, gap.

Item properties: order, flex-grow, flex-shrink, flex-basis, flex, align-self.


The object-fit property in CSS is used to control how an image or video fits inside its container (like a <div>, <img>, or <video>).

Normally, if the image size doesn’t match the container, it may stretch, cut off, or leave empty space.
object-fit helps you decide what should happen.

🔹 Syntax
img {
  object-fit: value;
}

✅ Values of object-fit

fill (default)
👉 The image stretches to fill the container. It may look distorted.

object-fit: fill;


contain
👉 The whole image fits inside the container, keeping its aspect ratio.
But it may leave empty space (letterboxing).

object-fit: contain;


cover
👉 The image covers the entire container while keeping aspect ratio.
Some parts may be cropped.

object-fit: cover;


none
👉 The image keeps its original size (not resized).
If bigger than the container, it will overflow.

object-fit: none;


scale-down
👉 The image is sized as either none or contain, whichever is smaller.

object-fit: scale-down;

🔹 Example
<div style="width:200px; height:150px; border:2px solid black;">
  <img src="https://www.w3schools.com/w3images/house5.jpg" 
       style="width:100%; height:100%; object-fit:cover;">
</div>


👉 Here the image will fill the box without distortion (but may crop).

✅ In short:

contain = show whole image (might leave space).

cover = fill box completely (might crop).

fill = stretch (can distort).

none = keep real size.

scale-down = smallest between none & contain.

🔹 What is a CSS Transition?

A transition in CSS allows you to smoothly change a CSS property from one value to another, instead of instantly jumping.

👉 Example:

.box {
  width: 100px;
  height: 100px;
  background: blue;
  transition: all 0.5s; /* smooth change in 0.5s */
}

.box:hover {
  width: 200px;
  background: red;
}


✅ When you hover, the box smoothly grows and changes color in half a second.

🔹 Transition Properties

There are 4 main transition properties:

transition-property

Which CSS property should animate?

Example:

transition-property: width, background-color;


transition-duration

How long the transition takes.

Example:

transition-duration: 0.5s; /* 0.5 seconds */


transition-timing-function

The speed curve of the animation.

Options:

ease (default) → starts slow, fast in middle, slow at end

linear → constant speed

ease-in → starts slow, then fast

ease-out → starts fast, ends slow

ease-in-out → slow → fast → slow

cubic-bezier(...) → custom curve

Example:

transition-timing-function: ease-in-out;


transition-delay

Wait before starting the transition.

Example:

transition-delay: 0.3s; /* wait 0.3s, then start */

🔹 Shorthand

Instead of writing all 4 separately, you can write in one line:

transition: property duration timing-function delay;


👉 Example:

transition: width 0.5s ease-in-out 0.2s;


Animates width

Takes 0.5s

Uses ease-in-out

Starts after 0.2s delay

✅ Summary in one line:
Transitions make property changes smooth instead of instant, using transition-property, transition-duration, transition-timing-function, and transition-delay.
-->
<!-- 
🔹 What is transform?

The transform property in CSS is used to change the shape, size, and position of an element without disturbing the rest of the layout.

👉 Think of it like moving, rotating, zooming, or skewing an element on the page.

🔹 Common Transform Functions

translate(x, y) → Moves an element

.box {
  transform: translate(50px, 20px); /* move 50px right, 20px down */
}


rotate(angle) → Rotates an element

.box {
  transform: rotate(45deg); /* rotate 45 degrees */
}


scale(x, y) → Zoom in or out (resize)

.box {
  transform: scale(1.5);   /* 1.5 times bigger */
  transform: scale(0.5);   /* half size */
}


skew(x, y) → Slant the element

.box {
  transform: skew(20deg, 10deg); /* skew horizontally and vertically */
}


matrix(a, b, c, d, e, f) → Combines all transforms in one (advanced).

🔹 Example
.box {
  width: 100px;
  height: 100px;
  background: blue;
  transition: transform 0.5s;
}

.box:hover {
  transform: scale(1.2) rotate(15deg) translate(20px, 10px);
}


✅ When you hover:

Box zooms in

Rotates

Moves to the side

🔹 Transform + Transform-origin

You can also change where the transform happens from:

.box {
  transform-origin: top left; /* rotate around top-left corner */
}


✅ Summary:
The transform property lets you move, rotate, scale, and skew elements in 2D (and even 3D with rotateX, rotateY, perspective).

 -->

 <!-- 
 🔹 3. Transform + Transition Together

They are often used together:

transform → defines what change happens (rotate, scale, move).

transition → defines how smoothly that change happens.

👉 Example:

.box {
  width: 100px;
  height: 100px;
  background: red;
  transition: transform 0.5s ease; /* smooth animation */
}

.box:hover {
  transform: rotate(45deg) scale(1.2); /* rotate + zoom smoothly */
}


✅ Hover → box rotates and zooms smoothly in half a second.

🔹 Key Difference in One Line:

Transform = “What change happens” (move, rotate, scale, skew).

Transition = “How the change happens” (speed, smoothness, delay).
  -->


  <!-- units -->
  <!-- 
      1️⃣ Absolute Units – Fixed size

These stay the same no matter the screen size.

px (pixels) – The most common unit. Example: font-size: 16px;

cm, mm, in – Centimeters, millimeters, inches (rarely used for screens).

pt, pc – Points and picas (mainly for print).

👉 Example:

p { font-size: 20px; } /* Always 20 pixels */

2️⃣ Relative Units – Change based on screen or parent element

These adjust according to the device or parent element, making websites more responsive.

% (percentage) – Based on the parent’s size. Example: width: 50%;

em – Based on the font size of the parent element.

rem – Based on the root (html) font size.

vw (viewport width) – Based on the width of the browser window (1vw = 1% of viewport width).

vh (viewport height) – Based on the height of the browser window (1vh = 1% of viewport height).

👉 Example:

div { width: 50%; } /* Half of the parent’s width */
h1 { font-size: 2rem; } /* Twice the root font size */

🔑 Key Tip:

Use px when you need fixed sizes.

Use %, em, rem, vw, and vh for responsive design so your site looks good on all devices.
  -->

  <!-- 
  
  In CSS, pseudo-classes and pseudo-elements let you style elements in special situations without needing extra HTML.
They sound similar but have different purposes:

✅ Pseudo-classes (start with :)

👉 They target an existing element when it is in a specific state.

Examples:

:hover → When the mouse is over an element.

:focus → When an input is active (clicked or typed in).

:first-child → Styles the first child of a parent.

:nth-child(2) → Styles the 2nd child.

Example:

button:hover {
  background-color: lightblue; /* Changes color when hovered */
}

🎯 Pseudo-elements (start with ::)

👉 They let you create and style a part of an element that isn’t in the HTML.

Examples:

::before → Adds content before an element.

::after → Adds content after an element.

::first-letter → Styles only the first letter of a text.

::selection → Styles text when it’s highlighted.

Example:

p::first-letter {
  font-size: 30px; /* Makes the first letter big */
  color: red;
}
p::after {
  content: " ✔"; /* Adds a check mark after the text */
}

🔑 Difference in One Line:

Pseudo-class (:) → Styles an element’s state (hover, focus, first-child).

Pseudo-element (::) → Styles or creates a part of an element (before, after, first-letter).
  -->

<!-- media queries--
  Media queries in CSS are rules that let your website change its style based on the device’s screen size, orientation, or other properties.
They are key for responsive design, so a site looks good on phones, tablets, and desktops.

🔹 Basic Idea

A media query checks the conditions (like screen width) and applies styles only if the condition is true.

✅ Syntax:
@media (condition) {
  /* CSS rules here */
}

✅ Common Example – Responsive Layout:
/* Default style for large screens */
body {
  background-color: lightblue;
}

/* Change for screens smaller than 600px (mobile) */
@media (max-width: 600px) {
  body {
    background-color: lightpink;
  }
}


📱 Here, if the screen width is 600px or less, the background turns pink.

📏 Common Conditions:

max-width: Apply styles when screen is smaller than a value.

min-width: Apply styles when screen is larger than a value.

orientation: portrait or landscape.

prefers-color-scheme: dark or light mode.

Example:

@media (orientation: portrait) {
  p { font-size: 20px; }
}

💡 Quick Tip:

Use min-width for a mobile-first approach (start small, grow styles).

Combine conditions with and:

@media (min-width: 600px) and (max-width: 900px) { ... }
-->

<head>
    <link rel="stylesheet" href="css1.css">
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Css-1</title>
</head>
<body>
    <div class="container">
        <p>This is a simple card using a CSS box model.</p>
    </div>
</body>
</html>